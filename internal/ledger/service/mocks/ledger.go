// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"

	models "github.com/mavrk-mose/pay/internal/ledger/models"

	sqlx "github.com/jmoiron/sqlx"
)

// LedgerService is an autogenerated mock type for the LedgerService type
type LedgerService struct {
	mock.Mock
}

type LedgerService_Expecter struct {
	mock *mock.Mock
}

func (_m *LedgerService) EXPECT() *LedgerService_Expecter {
	return &LedgerService_Expecter{mock: &_m.Mock}
}

// CreateTransactionWithEntries provides a mock function with given fields: ctx, txn, entries
func (_m *LedgerService) CreateTransactionWithEntries(ctx *gin.Context, txn *sqlx.Tx, entries []models.Transaction) error {
	ret := _m.Called(ctx, txn, entries)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransactionWithEntries")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, *sqlx.Tx, []models.Transaction) error); ok {
		r0 = rf(ctx, txn, entries)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LedgerService_CreateTransactionWithEntries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransactionWithEntries'
type LedgerService_CreateTransactionWithEntries_Call struct {
	*mock.Call
}

// CreateTransactionWithEntries is a helper method to define mock.On call
//   - ctx *gin.Context
//   - txn *sqlx.Tx
//   - entries []models.Transaction
func (_e *LedgerService_Expecter) CreateTransactionWithEntries(ctx interface{}, txn interface{}, entries interface{}) *LedgerService_CreateTransactionWithEntries_Call {
	return &LedgerService_CreateTransactionWithEntries_Call{Call: _e.mock.On("CreateTransactionWithEntries", ctx, txn, entries)}
}

func (_c *LedgerService_CreateTransactionWithEntries_Call) Run(run func(ctx *gin.Context, txn *sqlx.Tx, entries []models.Transaction)) *LedgerService_CreateTransactionWithEntries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gin.Context), args[1].(*sqlx.Tx), args[2].([]models.Transaction))
	})
	return _c
}

func (_c *LedgerService_CreateTransactionWithEntries_Call) Return(_a0 error) *LedgerService_CreateTransactionWithEntries_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LedgerService_CreateTransactionWithEntries_Call) RunAndReturn(run func(*gin.Context, *sqlx.Tx, []models.Transaction) error) *LedgerService_CreateTransactionWithEntries_Call {
	_c.Call.Return(run)
	return _c
}

// FetchTransactionsWithChecksum provides a mock function with given fields: db, date, provider
func (_m *LedgerService) FetchTransactionsWithChecksum(db *sqlx.DB, date string, provider string) (map[string]string, error) {
	ret := _m.Called(db, date, provider)

	if len(ret) == 0 {
		panic("no return value specified for FetchTransactionsWithChecksum")
	}

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(*sqlx.DB, string, string) (map[string]string, error)); ok {
		return rf(db, date, provider)
	}
	if rf, ok := ret.Get(0).(func(*sqlx.DB, string, string) map[string]string); ok {
		r0 = rf(db, date, provider)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(*sqlx.DB, string, string) error); ok {
		r1 = rf(db, date, provider)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LedgerService_FetchTransactionsWithChecksum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchTransactionsWithChecksum'
type LedgerService_FetchTransactionsWithChecksum_Call struct {
	*mock.Call
}

// FetchTransactionsWithChecksum is a helper method to define mock.On call
//   - db *sqlx.DB
//   - date string
//   - provider string
func (_e *LedgerService_Expecter) FetchTransactionsWithChecksum(db interface{}, date interface{}, provider interface{}) *LedgerService_FetchTransactionsWithChecksum_Call {
	return &LedgerService_FetchTransactionsWithChecksum_Call{Call: _e.mock.On("FetchTransactionsWithChecksum", db, date, provider)}
}

func (_c *LedgerService_FetchTransactionsWithChecksum_Call) Run(run func(db *sqlx.DB, date string, provider string)) *LedgerService_FetchTransactionsWithChecksum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*sqlx.DB), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *LedgerService_FetchTransactionsWithChecksum_Call) Return(_a0 map[string]string, _a1 error) *LedgerService_FetchTransactionsWithChecksum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LedgerService_FetchTransactionsWithChecksum_Call) RunAndReturn(run func(*sqlx.DB, string, string) (map[string]string, error)) *LedgerService_FetchTransactionsWithChecksum_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionByID provides a mock function with given fields: transactionID
func (_m *LedgerService) GetTransactionByID(transactionID string) (models.Transaction, error) {
	ret := _m.Called(transactionID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 models.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (models.Transaction, error)); ok {
		return rf(transactionID)
	}
	if rf, ok := ret.Get(0).(func(string) models.Transaction); ok {
		r0 = rf(transactionID)
	} else {
		r0 = ret.Get(0).(models.Transaction)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(transactionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LedgerService_GetTransactionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionByID'
type LedgerService_GetTransactionByID_Call struct {
	*mock.Call
}

// GetTransactionByID is a helper method to define mock.On call
//   - transactionID string
func (_e *LedgerService_Expecter) GetTransactionByID(transactionID interface{}) *LedgerService_GetTransactionByID_Call {
	return &LedgerService_GetTransactionByID_Call{Call: _e.mock.On("GetTransactionByID", transactionID)}
}

func (_c *LedgerService_GetTransactionByID_Call) Run(run func(transactionID string)) *LedgerService_GetTransactionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LedgerService_GetTransactionByID_Call) Return(_a0 models.Transaction, _a1 error) *LedgerService_GetTransactionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LedgerService_GetTransactionByID_Call) RunAndReturn(run func(string) (models.Transaction, error)) *LedgerService_GetTransactionByID_Call {
	_c.Call.Return(run)
	return _c
}

// RecordTransaction provides a mock function with given fields: ctx, txn
func (_m *LedgerService) RecordTransaction(ctx *gin.Context, txn models.Transaction) (string, error) {
	ret := _m.Called(ctx, txn)

	if len(ret) == 0 {
		panic("no return value specified for RecordTransaction")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*gin.Context, models.Transaction) (string, error)); ok {
		return rf(ctx, txn)
	}
	if rf, ok := ret.Get(0).(func(*gin.Context, models.Transaction) string); ok {
		r0 = rf(ctx, txn)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*gin.Context, models.Transaction) error); ok {
		r1 = rf(ctx, txn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LedgerService_RecordTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordTransaction'
type LedgerService_RecordTransaction_Call struct {
	*mock.Call
}

// RecordTransaction is a helper method to define mock.On call
//   - ctx *gin.Context
//   - txn models.Transaction
func (_e *LedgerService_Expecter) RecordTransaction(ctx interface{}, txn interface{}) *LedgerService_RecordTransaction_Call {
	return &LedgerService_RecordTransaction_Call{Call: _e.mock.On("RecordTransaction", ctx, txn)}
}

func (_c *LedgerService_RecordTransaction_Call) Run(run func(ctx *gin.Context, txn models.Transaction)) *LedgerService_RecordTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gin.Context), args[1].(models.Transaction))
	})
	return _c
}

func (_c *LedgerService_RecordTransaction_Call) Return(_a0 string, _a1 error) *LedgerService_RecordTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LedgerService_RecordTransaction_Call) RunAndReturn(run func(*gin.Context, models.Transaction) (string, error)) *LedgerService_RecordTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTransactionStatus provides a mock function with given fields: ctx, externalRef, status
func (_m *LedgerService) UpdateTransactionStatus(ctx *gin.Context, externalRef string, status models.TransactionStatus) error {
	ret := _m.Called(ctx, externalRef, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransactionStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, string, models.TransactionStatus) error); ok {
		r0 = rf(ctx, externalRef, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LedgerService_UpdateTransactionStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTransactionStatus'
type LedgerService_UpdateTransactionStatus_Call struct {
	*mock.Call
}

// UpdateTransactionStatus is a helper method to define mock.On call
//   - ctx *gin.Context
//   - externalRef string
//   - status models.TransactionStatus
func (_e *LedgerService_Expecter) UpdateTransactionStatus(ctx interface{}, externalRef interface{}, status interface{}) *LedgerService_UpdateTransactionStatus_Call {
	return &LedgerService_UpdateTransactionStatus_Call{Call: _e.mock.On("UpdateTransactionStatus", ctx, externalRef, status)}
}

func (_c *LedgerService_UpdateTransactionStatus_Call) Run(run func(ctx *gin.Context, externalRef string, status models.TransactionStatus)) *LedgerService_UpdateTransactionStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gin.Context), args[1].(string), args[2].(models.TransactionStatus))
	})
	return _c
}

func (_c *LedgerService_UpdateTransactionStatus_Call) Return(_a0 error) *LedgerService_UpdateTransactionStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LedgerService_UpdateTransactionStatus_Call) RunAndReturn(run func(*gin.Context, string, models.TransactionStatus) error) *LedgerService_UpdateTransactionStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewLedgerService creates a new instance of LedgerService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLedgerService(t interface {
	mock.TestingT
	Cleanup(func())
}) *LedgerService {
	mock := &LedgerService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
