// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"

	models "github.com/mavrk-mose/pay/internal/ledger/models"

	sqlx "github.com/jmoiron/sqlx"
)

// TransactionRepo is an autogenerated mock type for the TransactionRepo type
type TransactionRepo struct {
	mock.Mock
}

// CreateTransactionWithEntries provides a mock function with given fields: ctx, txn, entries
func (_m *TransactionRepo) CreateTransactionWithEntries(ctx *gin.Context, txn *sqlx.Tx, entries []models.Transaction) error {
	ret := _m.Called(ctx, txn, entries)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransactionWithEntries")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, *sqlx.Tx, []models.Transaction) error); ok {
		r0 = rf(ctx, txn, entries)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchTransactionsWithChecksum provides a mock function with given fields: db, date, provider
func (_m *TransactionRepo) FetchTransactionsWithChecksum(db *sqlx.DB, date string, provider string) (map[string]string, error) {
	ret := _m.Called(db, date, provider)

	if len(ret) == 0 {
		panic("no return value specified for FetchTransactionsWithChecksum")
	}

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(*sqlx.DB, string, string) (map[string]string, error)); ok {
		return rf(db, date, provider)
	}
	if rf, ok := ret.Get(0).(func(*sqlx.DB, string, string) map[string]string); ok {
		r0 = rf(db, date, provider)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(*sqlx.DB, string, string) error); ok {
		r1 = rf(db, date, provider)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecordTransaction provides a mock function with given fields: ctx, payerWalletID, payeeWalletID, amount, currency
func (_m *TransactionRepo) RecordTransaction(ctx *gin.Context, payerWalletID int64, payeeWalletID int64, amount float64, currency string) (string, error) {
	ret := _m.Called(ctx, payerWalletID, payeeWalletID, amount, currency)

	if len(ret) == 0 {
		panic("no return value specified for RecordTransaction")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*gin.Context, int64, int64, float64, string) (string, error)); ok {
		return rf(ctx, payerWalletID, payeeWalletID, amount, currency)
	}
	if rf, ok := ret.Get(0).(func(*gin.Context, int64, int64, float64, string) string); ok {
		r0 = rf(ctx, payerWalletID, payeeWalletID, amount, currency)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*gin.Context, int64, int64, float64, string) error); ok {
		r1 = rf(ctx, payerWalletID, payeeWalletID, amount, currency)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTransactionStatus provides a mock function with given fields: ctx, externalRef, status
func (_m *TransactionRepo) UpdateTransactionStatus(ctx *gin.Context, externalRef string, status models.TransactionStatus) error {
	ret := _m.Called(ctx, externalRef, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransactionStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, string, models.TransactionStatus) error); ok {
		r0 = rf(ctx, externalRef, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewTransactionRepo creates a new instance of TransactionRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransactionRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *TransactionRepo {
	mock := &TransactionRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
